<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DfsBProgramVerifier.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bp-ide-bpjs-bp-framework</a> &gt; <a href="index.source.html" class="el_package">il.ac.bgu.cs.bp.bpjs.analysis</a> &gt; <span class="el_source">DfsBProgramVerifier.java</span></div><h1>DfsBProgramVerifier.java</h1><pre class="source lang-java linenums">/*
 * The MIT License
 *
 * Copyright 2017 michael.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package il.ac.bgu.cs.bp.bpjs.analysis;

import il.ac.bgu.cs.bp.bpjs.analysis.violations.JsErrorViolation;
import il.ac.bgu.cs.bp.bpjs.analysis.violations.Violation;
import il.ac.bgu.cs.bp.bpjs.exceptions.BPjsRuntimeException;
import java.util.ArrayList;
import java.util.List;

import il.ac.bgu.cs.bp.bpjs.execution.listeners.BProgramRunnerListener;
import il.ac.bgu.cs.bp.bpjs.model.BProgram;
import il.ac.bgu.cs.bp.bpjs.model.BEvent;
import il.ac.bgu.cs.bp.bpjs.internal.ExecutorServiceMaker;
import il.ac.bgu.cs.bp.bpjs.model.BProgramSyncSnapshot;
import java.util.Collections;
import java.util.HashSet;

import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.atomic.AtomicInteger;
import static java.util.stream.Collectors.toSet;

/**
 * Takes a {@link BProgram}, and verifies that it does not run into false
 * assertions or deadlock, given all possible event selections.
 * Take care to use the appropriate {@link VisitedStateStore} for the
 * {@link BProgram} being verified.
 * &lt;p&gt;
 * States are scanned using a DFS.
 *
 * @author michael
 */
<span class="fc" id="L56">public class DfsBProgramVerifier {</span>

<span class="fc" id="L58">    private static final AtomicInteger INSTANCE_COUNTER = new AtomicInteger();</span>
    public final static long DEFAULT_MAX_TRACE = 1000;

    /**
     * Default number of iterations between invoking the progress listeners.
     */
    public final static long DEFAULT_ITERATION_COUNT_GAP = 1000;

    /**
     * A listener to the progress of the DFS state scanning.
     */
    public static interface ProgressListener {
        
        /**
         * Verifier {@code vfr} started a verification process.
         * @param vfr the verifier
         */
        void started(DfsBProgramVerifier vfr);

        /**
         * A periodical call to update progress.
         * @param count count of iterations.
         * @param statesHit count of states found.
         * @param vfr the verifier
         * @see DfsBProgramVerifier#setIterationCountGap(long) 
         */
        void iterationCount(long count, long statesHit, DfsBProgramVerifier vfr);
        
        /**
         * Verifier {@code vfr} hit the max trace length, and now pops its
         * iteration stack.
         * @param aTrace The trace the verifier examined when it hit the length limit.
         * @param vfr The verifier.
         * @see DfsBProgramVerifier#setMaxTraceLength(long) 
         */
        void maxTraceLengthHit(ExecutionTrace aTrace, DfsBProgramVerifier vfr);
        
        /**
         * Verifier {@code vfr} reports a found violation. It is up to the listener
         * to decide whether to continue the verification process and find more 
         * violations, or to terminate and return the current violation to the 
         * caller.
         * 
         * @param aViolation the violation found
         * @param vfr the verifier that found the violation
         * @return {@code true} for the verifier to continue the search, {@code false} otherwise.
         */
        boolean violationFound( Violation aViolation, DfsBProgramVerifier vfr );
        
        /**
         * The verifier {@code vfr} has finished the verification process.
         * @param vfr the verifier that found the violation
         */
        void done(DfsBProgramVerifier vfr);
    }
    
    private static class ViolatingPathFoundException extends Exception {
        final Violation v;

<span class="nc" id="L117">        public ViolatingPathFoundException(Violation v) {</span>
<span class="nc" id="L118">            this.v = v;</span>
<span class="nc" id="L119">        }</span>
    }
    
    /**
     * A &quot;null object&quot; progress listener instance. Stops verification at the 
     * first violation found. Otherwise does nothing.
     */
<span class="fc" id="L126">    private static final ProgressListener NULL_PROGRESS_LISTENER = new ProgressListener() {</span>
<span class="fc" id="L127">        @Override public void started(DfsBProgramVerifier vfr) {}</span>
<span class="nc" id="L128">        @Override public void iterationCount(long count, long statesHit, DfsBProgramVerifier vfr) {}</span>
<span class="nc" id="L129">        @Override public void maxTraceLengthHit(ExecutionTrace aTrace, DfsBProgramVerifier vfr) {}</span>
<span class="fc" id="L130">        @Override public void done(DfsBProgramVerifier vfr) {}</span>

        @Override
        public boolean violationFound(Violation aViolation, DfsBProgramVerifier vfr) {
<span class="fc" id="L134">            return false;</span>
        }
    };
        
    
    private long visitedEdgeCount;
<span class="fc" id="L140">    private VisitedStateStore visited = new BThreadSnapshotVisitedStateStore();</span>
<span class="fc" id="L141">    private long maxTraceLength = DEFAULT_MAX_TRACE;</span>
<span class="fc" id="L142">    private final List&lt;DfsTraversalNode&gt; currentPath = new ArrayList&lt;&gt;();</span>
    private ProgressListener listener;
<span class="fc" id="L144">    private long iterationCountGap = DEFAULT_ITERATION_COUNT_GAP;</span>
    private BProgram currentBProgram;
<span class="fc" id="L146">    private boolean debugMode = false;</span>
<span class="fc" id="L147">    private final Set&lt;ExecutionTraceInspection&gt; inspections = new HashSet&lt;&gt;();</span>
    private ArrayExecutionTrace trace;
<span class="fc" id="L149">    protected List&lt;BProgramRunnerListener&gt; listeners = Collections.emptyList();</span>

    public VerificationResult verify(BProgram aBp) throws Exception {
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        if ( listener == null ) {</span>
<span class="fc" id="L153">            listener = NULL_PROGRESS_LISTENER;</span>
        }
<span class="fc" id="L155">        currentBProgram = aBp;</span>
<span class="fc" id="L156">        visitedEdgeCount = 0;</span>
<span class="fc" id="L157">        currentPath.clear();</span>
<span class="fc" id="L158">        visited.clear();</span>
<span class="fc" id="L159">        trace = new ArrayExecutionTrace(currentBProgram);</span>
        
        // in case no verifications were specified, use the defauls set.
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if ( inspections.isEmpty() ) { </span>
<span class="fc" id="L163">            inspections.addAll( ExecutionTraceInspections.DEFAULT_SET );</span>
        }
        
<span class="fc" id="L166">        ExecutorService execSvc = ExecutorServiceMaker.makeWithName(&quot;DfsBProgramRunner-&quot; + INSTANCE_COUNTER.incrementAndGet());</span>
<span class="fc" id="L167">        long start = System.currentTimeMillis();</span>
<span class="fc" id="L168">        listener.started(this);</span>
<span class="fc" id="L169">        Violation vio = dfsUsingStack(new DfsTraversalNode(currentBProgram, currentBProgram.setup().start(execSvc), null), execSvc);</span>
<span class="fc" id="L170">        long end = System.currentTimeMillis();</span>
<span class="fc" id="L171">        execSvc.shutdown();</span>
<span class="fc" id="L172">        listener.done(this);</span>
<span class="fc" id="L173">        return new VerificationResult(vio, end - start, visited.getVisitedStateCount(), visitedEdgeCount);</span>
    }

    protected Violation dfsUsingStack(DfsTraversalNode aStartNode, ExecutorService execSvc) throws Exception {
<span class="fc" id="L177">        long iterationCount = 0;</span>

<span class="fc" id="L179">        push(aStartNode);</span>
<span class="fc" id="L180">        Violation v = inspectCurrentTrace();</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        if ( v != null ) return v;</span>
                            
<span class="fc bfc" id="L183" title="All 2 branches covered.">        while (!isPathEmpty()) {</span>
<span class="fc" id="L184">            iterationCount++;</span>
            
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">            if (debugMode) {</span>
<span class="nc" id="L187">                printStatus(iterationCount, currentPath);</span>
            }

<span class="fc" id="L190">            DfsTraversalNode curNode = peek();            </span>

<span class="pc bpc" id="L192" title="1 of 2 branches missed.">            if (pathLength() == maxTraceLength) {</span>
                // fold stack;
<span class="nc" id="L194">                listener.maxTraceLengthHit(trace, this);</span>
<span class="nc" id="L195">                pop();</span>

            } else {
                try {
<span class="fc" id="L199">                    DfsTraversalNode nextNode = getUnvisitedNextNode(curNode, execSvc);</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">                    if (nextNode == null) {</span>
                        // fold stack, retry next iteration;
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">                        if (isDebugMode()) {</span>
<span class="nc" id="L203">                            System.out.println(&quot;-pop!-&quot;);</span>
                        }
<span class="fc" id="L205">                        DfsTraversalNode p = pop();</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">                        if ( p.getEventIterator().hasNext() ) {</span>
<span class="nc" id="L207">                            throw new IllegalStateException(&quot;Still having some events to traverse: &quot; + p.getEventIterator().next() );</span>
                        }
                        
<span class="fc" id="L210">                    } else {</span>
                        // go deeper 
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">                        if (isDebugMode()) {</span>
<span class="nc" id="L213">                            System.out.println(&quot;-visiting: &quot; + nextNode);</span>
                        }
<span class="fc" id="L215">                        push(nextNode);</span>
<span class="fc" id="L216">                        v = inspectCurrentTrace();</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">                        if ( v != null ) return v;</span>
                    }
<span class="nc" id="L219">                } catch (ViolatingPathFoundException vcfe ) {</span>
<span class="nc" id="L220">                    return vcfe.v;</span>
<span class="fc" id="L221">                }</span>
            }
            
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">            if ( iterationCount % iterationCountGap == 0 ) {</span>
<span class="nc" id="L225">                listener.iterationCount(iterationCount, visited.getVisitedStateCount(), this);</span>
            }
<span class="fc" id="L227">        }</span>

<span class="fc" id="L229">        return null;</span>
    }

    protected DfsTraversalNode getUnvisitedNextNode(DfsTraversalNode src, ExecutorService execSvc) 
        throws ViolatingPathFoundException{
<span class="fc bfc" id="L234" title="All 2 branches covered.">        while (src.getEventIterator().hasNext()) {</span>
<span class="fc" id="L235">            final BEvent nextEvent = src.getEventIterator().next();</span>
            try {
<span class="fc" id="L237">                DfsTraversalNode possibleNextNode = src.getNextNode(nextEvent, listeners, execSvc);</span>
<span class="fc" id="L238">                visitedEdgeCount++;</span>

<span class="fc" id="L240">                BProgramSyncSnapshot pns = possibleNextNode.getSystemState();</span>
<span class="fc" id="L241">                int stateIndexOnTrace = trace.indexOf(pns);</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">                if ( stateIndexOnTrace &gt; -1 ) {</span>
                    // cycle found
<span class="fc" id="L244">                    trace.cycleTo(nextEvent, stateIndexOnTrace);</span>
<span class="fc" id="L245">                    Set&lt;Violation&gt; res = inspections.stream().map(i-&gt;i.inspectTrace(trace))</span>
<span class="fc" id="L246">                        .filter(o-&gt;o.isPresent()).map(Optional::get).collect(toSet());</span>

<span class="pc bpc" id="L248" title="1 of 2 branches missed.">                    for ( Violation v : res ) {</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">                        if ( ! listener.violationFound(v, this)) {</span>
<span class="nc" id="L250">                            throw new ViolatingPathFoundException(v);</span>
                        }
<span class="nc" id="L252">                    }</span>
                    
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">                } else if ( visited.isVisited(pns) ) {</span>
                    // non cyclic, revisiting a state from a different path.
                    //     ... Quickly inspect the path and continue.
<span class="nc" id="L257">                    trace.advance(nextEvent, pns);</span>
<span class="nc" id="L258">                    Set&lt;Violation&gt; res = inspections.stream().map(i-&gt;i.inspectTrace(trace))</span>
<span class="nc" id="L259">                            .filter(o-&gt;o.isPresent()).map(Optional::get).collect(toSet());</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">                    if ( res.size() &gt; 0  ) {</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">                        for ( Violation v : res ) {</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">                            if ( ! listener.violationFound(v, this) ) {</span>
<span class="nc" id="L263">                                throw new ViolatingPathFoundException(v);</span>
                            }
<span class="nc" id="L265">                        }</span>
                    }
<span class="nc" id="L267">                    trace.pop();</span>
                    
<span class="nc" id="L269">                } else {</span>
                    // advance to this newly discovered node
<span class="fc" id="L271">                    return possibleNextNode;</span>
                }
                
<span class="nc" id="L274">            } catch ( BPjsRuntimeException bprte ) {</span>
<span class="nc" id="L275">                trace.advance(nextEvent, null);</span>
<span class="nc" id="L276">                Violation jsev = new JsErrorViolation(trace, bprte);</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">                if ( ! listener.violationFound(jsev, this) ) {</span>
<span class="nc" id="L278">                    throw new ViolatingPathFoundException(jsev);</span>
                }
<span class="nc" id="L280">                trace.pop();</span>
<span class="fc" id="L281">            }</span>
<span class="fc" id="L282">        }</span>
<span class="fc" id="L283">        return null;</span>
    }

    public void setMaxTraceLength(long maxTraceLength) {
<span class="fc" id="L287">        this.maxTraceLength = maxTraceLength;</span>
<span class="fc" id="L288">    }</span>

    public long getMaxTraceLength() {
<span class="nc" id="L291">        return maxTraceLength;</span>
    }

    public void setVisitedStateStore(VisitedStateStore aVisitedStateStore) {
<span class="fc" id="L295">        visited = aVisitedStateStore;</span>
<span class="fc" id="L296">    }</span>

    public VisitedStateStore getVisitedStateStore() {
<span class="nc" id="L299">        return visited;</span>
    }

    public void setProgressListener(ProgressListener pl) {
<span class="nc bnc" id="L303" title="All 2 branches missed.">        listener = (pl != null) ? pl : NULL_PROGRESS_LISTENER;</span>
<span class="nc" id="L304">    }</span>

    public void setIterationCountGap(long iterationCountGap) {
<span class="nc" id="L307">        this.iterationCountGap = iterationCountGap;</span>
<span class="nc" id="L308">    }</span>

    public long getIterationCountGap() {
<span class="nc" id="L311">        return iterationCountGap;</span>
    }

    public BProgram getCurrentBProgram() {
<span class="nc" id="L315">        return currentBProgram;</span>
    }

    void printStatus(long iteration, List&lt;DfsTraversalNode&gt; path) {
<span class="nc" id="L319">        System.out.println(&quot;Iteration &quot; + iteration);</span>
<span class="nc" id="L320">        System.out.println(&quot;  visited: &quot; + visited.getVisitedStateCount());</span>
<span class="nc" id="L321">        path.forEach(n -&gt; System.out.println(&quot;  &quot; + n.getLastEvent()));</span>
<span class="nc" id="L322">    }</span>
    
    private Violation inspectCurrentTrace() {
<span class="fc" id="L325">        Set&lt;Violation&gt; res = inspections.stream()</span>
<span class="fc" id="L326">                                    .map(v-&gt;v.inspectTrace(trace))</span>
<span class="fc" id="L327">                                    .filter(o-&gt;o.isPresent()).map(Optional::get)</span>
<span class="fc" id="L328">                                    .collect(toSet());</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">        if ( res.size() &gt; 0  ) {</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">            for ( Violation v : res ) {</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">                if ( ! listener.violationFound(v, this) ) {</span>
<span class="fc" id="L332">                    return v;</span>
                }
<span class="nc" id="L334">            }</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">            if (isDebugMode()) {</span>
<span class="nc" id="L336">                System.out.println(&quot;-pop! (violation)-&quot;);</span>
            }
<span class="nc" id="L338">            pop();</span>
        }
<span class="fc" id="L340">        return null;</span>
    }
    
    private void push(DfsTraversalNode n) {
<span class="fc" id="L344">        visited.store(n.getSystemState());</span>
<span class="fc" id="L345">        currentPath.add(n);</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">        if ( trace.getStateCount() == 0 ) {</span>
<span class="fc" id="L347">            trace.push( n.getSystemState() );</span>
        } else {
<span class="fc" id="L349">            trace.advance(n.getLastEvent(), n.getSystemState());</span>
        }
<span class="fc" id="L351">    }</span>

    private DfsTraversalNode pop() {
<span class="fc" id="L354">        DfsTraversalNode popped = currentPath.remove(currentPath.size() - 1);</span>
<span class="fc" id="L355">        trace.pop();</span>
<span class="fc" id="L356">        return popped;</span>
    }

    private int pathLength() {
<span class="fc" id="L360">        return currentPath.size();</span>
    }

    private boolean isPathEmpty() {
<span class="fc bfc" id="L364" title="All 2 branches covered.">        return pathLength() == 0;</span>
    }

    private DfsTraversalNode peek() {
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">        return isPathEmpty() ? null : currentPath.get(currentPath.size() - 1);</span>
    }

    public boolean isDebugMode() {
<span class="fc" id="L372">        return debugMode;</span>
    }

    public void setDebugMode(boolean debugMode) {
<span class="nc" id="L376">        this.debugMode = debugMode;</span>
<span class="nc" id="L377">    }</span>
    
    public void addInspection( ExecutionTraceInspection ins ) {
<span class="fc" id="L380">        inspections.add(ins);</span>
<span class="fc" id="L381">    }</span>
    
    public Set&lt;ExecutionTraceInspection&gt; getInspections() {
<span class="nc" id="L384">        return inspections;</span>
    }
    
    public boolean removeInspection( ExecutionTraceInspection ins ) {
<span class="nc" id="L388">        return inspections.remove(ins);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>