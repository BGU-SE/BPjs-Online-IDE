<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BProgram.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bp-ide-bpjs-bp-framework</a> &gt; <a href="index.source.html" class="el_package">il.ac.bgu.cs.bp.bpjs.model</a> &gt; <span class="el_source">BProgram.java</span></div><h1>BProgram.java</h1><pre class="source lang-java linenums">package il.ac.bgu.cs.bp.bpjs.model;

import il.ac.bgu.cs.bp.bpjs.execution.jsproxy.BProgramJsProxy;
import il.ac.bgu.cs.bp.bpjs.model.eventselection.EventSelectionStrategy;
import il.ac.bgu.cs.bp.bpjs.model.eventselection.SimpleEventSelectionStrategy;

import java.util.*;
import java.util.concurrent.*;

import il.ac.bgu.cs.bp.bpjs.exceptions.BPjsCodeEvaluationException;
import il.ac.bgu.cs.bp.bpjs.exceptions.BPjsException;
import il.ac.bgu.cs.bp.bpjs.exceptions.BPjsRuntimeException;
import il.ac.bgu.cs.bp.bpjs.execution.jsproxy.BpLog;
import il.ac.bgu.cs.bp.bpjs.execution.tasks.FailedAssertionException;
import il.ac.bgu.cs.bp.bpjs.internal.ScriptableUtils;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import org.mozilla.javascript.Context;
import org.mozilla.javascript.ContextFactory;
import org.mozilla.javascript.ImporterTopLevel;
import org.mozilla.javascript.Scriptable;
import java.util.concurrent.atomic.AtomicInteger;
import org.mozilla.javascript.EcmaError;
import org.mozilla.javascript.EvaluatorException;
import org.mozilla.javascript.WrappedException;

/**
 * Base class for BPrograms. Provides the context (JavaScript scope, external
 * event queue, etc.) b-threads interact with while running. Concrete BProgram
 * extend this class by implementing the
 * {@link #setupProgramScope(org.mozilla.javascript.Scriptable)} method.
 *
 * For creating a BProgram that uses a single JavaScript file available in the
 * classpath, see {@link ResourceBProgram}. For creating them from a
 * hard-coded string, see {@link StringBProgram}.
 *
 * @author michael
 */
public abstract class BProgram {

    // ------------- Static Members ---------------
    /**
     * &quot;Poison pill&quot; to insert to the external event queue. Used only to turn
     * the wait-for-external-events mode off.
     */
<span class="fc" id="L49">    static final BEvent NO_MORE_WAIT_EXTERNAL = new BEvent(&quot;___bpjs-internal____NO_MORE_WAIT_EXTERNAL&quot;);</span>

    /**
     * Counter for giving anonymous instances some semantic name.
     */
<span class="fc" id="L54">    private static final AtomicInteger INSTANCE_COUNTER = new AtomicInteger();</span>

    /**
     * A callback interface invoked when a b-thread is added to {@code this}.
     */
    public interface BProgramCallback {

        void bthreadAdded(BProgram bp, BThreadSyncSnapshot theBThread);
    }

    // ------------- Instance Members ---------------
    private String name;

    /**
     * When {@code true}, the BProgram waits for an external event when no
     * internal ones are available. Corollary: the program does not terminate at
     * the end of a super-step.
     */
    private boolean waitForExternalEvents;

    /**
     * Events are enqueued here by external threads
     */
<span class="fc" id="L77">    private final BlockingQueue&lt;BEvent&gt; recentlyEnqueuedExternalEvents = new LinkedBlockingQueue&lt;&gt;();</span>

    /**
     * BThreads added between syncs are added here.
     */
<span class="fc" id="L82">    private final BlockingQueue&lt;BThreadSyncSnapshot&gt; recentlyRegisteredBthreads = new LinkedBlockingDeque&lt;&gt;();</span>
    
<span class="fc" id="L84">    private final BlockingQueue&lt;ForkStatement&gt; recentlyAddedForks = new LinkedBlockingDeque&lt;&gt;();</span>

<span class="fc" id="L86">    private volatile boolean started = false;</span>

    protected Scriptable programScope;

    private EventSelectionStrategy eventSelectionStrategy;

    private BProgramJsProxy jsProxy;
    
<span class="fc" id="L94">    private BpLog.LogLevel preSetLogLevel = null;</span>

    /**
     * Objects that client code wishes to put in scope before the scope is
     * initialized are collected here.
     */
<span class="fc" id="L100">    protected Map&lt;String, Object&gt; initialScopeValues = new HashMap&lt;&gt;();</span>

<span class="fc" id="L102">    private Optional&lt;BProgramCallback&gt; addBThreadCallback = Optional.empty();</span>

    private List&lt;String&gt; appendedCode;
    private List&lt;String&gt; prependedCode;

    /**
     * Constructs a BProgram with a default name, guaranteed to be unique within
     * a given run.
     */
    public BProgram() {
<span class="fc" id="L112">        this(&quot;BProgram-&quot; + INSTANCE_COUNTER.incrementAndGet());</span>
<span class="fc" id="L113">    }</span>

    /**
     * Constructs a BProgram with a specific name.
     *
     * @param aName name for the new BProgram.
     */
<span class="fc" id="L120">    public BProgram(String aName) {</span>
<span class="fc" id="L121">        name = aName;</span>
<span class="fc" id="L122">    }</span>

    /**
     * Creates a BProgram with a specific name and an event selection strategy.
     *
     * @param aName Name for the program.
     * @param anEss Event selection strategy.
     */
<span class="fc" id="L130">    public BProgram(String aName, EventSelectionStrategy anEss) {</span>
<span class="fc" id="L131">        name = aName;</span>
<span class="fc" id="L132">        eventSelectionStrategy = anEss;</span>
<span class="fc" id="L133">    }</span>

    /**
     * Adds more source code to be evaluated &lt;em&gt;after&lt;/em&gt;
     * {@link #setupProgramScope(org.mozilla.javascript.Scriptable)} is called.
     * This method allows to programatically add code, e.g. for adding standard
     * environment, mocking non-modeled parts for model-checking.
     *
     * @throws IllegalStateException if the code is appended after the bprogram
     * started.
     * @param source JavaScript source to be added at the end of the current source.
     */
    public void appendSource(String source) {
<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (started) {</span>
<span class="fc" id="L147">            throw new IllegalStateException(&quot;Cannot append code after the program had started.&quot;);</span>
        } else {
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">            if (appendedCode == null) {</span>
<span class="fc" id="L150">                appendedCode = new ArrayList&lt;&gt;();</span>
            }
<span class="fc" id="L152">            appendedCode.add(source);</span>
        }
<span class="fc" id="L154">    }</span>

    public void setContextFactory(ContextFactory cf){
<span class="nc" id="L157">        ContextFactory.getGlobalSetter().setContextFactoryGlobal(cf);</span>
<span class="nc" id="L158">    }</span>

    /**
     * Adds more source code to be evaluated &lt;em&gt;before&lt;/em&gt;
     * {@link #setupProgramScope(org.mozilla.javascript.Scriptable)} is called.
     * This method allows to programatically add code, e.g. for adding standard
     * environment, mocking non-modeled parts for model-checking.
     *
     * @throws IllegalStateException if the code is appended after the bprogram
     * started.
     * @param source JavaScript source to be added at the beginning of the current source.
     */
    public void prependSource(String source) {
<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (started) {</span>
<span class="fc" id="L172">            throw new IllegalStateException(&quot;Cannot append code after the program had started.&quot;);</span>
        } else {
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">            if (prependedCode == null) {</span>
<span class="fc" id="L175">                prependedCode = new ArrayList&lt;&gt;();</span>
            }
<span class="fc" id="L177">            prependedCode.add(source);</span>
        }
<span class="fc" id="L179">    }</span>

    /**
     * Reads and evaluates the code at the passed input stream. The stream is
     * read to its end, but is not closed.
     *
     * @param inStrm Input stream for reading the script to be evaluated.
     * @param scriptName for error reporting purposes.
     * @return Result of evaluating the code at {@code inStrm}.
     */
    protected Object evaluate(InputStream inStrm, String scriptName) {
<span class="fc" id="L190">        InputStreamReader streamReader = new InputStreamReader(inStrm, StandardCharsets.UTF_8);</span>
<span class="fc" id="L191">        BufferedReader br = new BufferedReader(streamReader);</span>
<span class="fc" id="L192">        StringBuilder sb = new StringBuilder();</span>
        String line;
        try {
<span class="fc bfc" id="L195" title="All 2 branches covered.">            while ((line = br.readLine()) != null) {</span>
<span class="fc" id="L196">                sb.append(line).append(&quot;\n&quot;);</span>
            }
<span class="nc" id="L198">        } catch (IOException e) {</span>
<span class="nc" id="L199">            throw new RuntimeException(&quot;error while reading javascript from stream&quot;, e);</span>
<span class="fc" id="L200">        }</span>
<span class="fc" id="L201">        String script = sb.toString();</span>
<span class="fc" id="L202">        return evaluate(script, scriptName);</span>
    }

    /**
     * Runs the passed code in the passed scope.
     *
     * @param script Code to evaluate
     * @param scriptName For error reporting purposes.
     * @return Result of code evaluation.
     */
    protected Object evaluate(String script, String scriptName) {
        try {
<span class="fc" id="L214">            Context curCtx = Context.getCurrentContext();</span>
<span class="fc" id="L215">            curCtx.setLanguageVersion(Context.VERSION_ES6);</span>
<span class="fc" id="L216">            curCtx.setOptimizationLevel(-1);</span>
<span class="fc" id="L217">            return curCtx.evaluateString(programScope, script, scriptName, 1, null);</span>
<span class="nc" id="L218">        } catch (EcmaError rerr) {</span>
<span class="nc" id="L219">            throw new BPjsCodeEvaluationException(rerr);</span>

<span class="nc" id="L221">        } catch (WrappedException wrapped) {</span>
            try {
<span class="nc" id="L223">                throw wrapped.getCause();</span>
<span class="nc" id="L224">            } catch (BPjsException be ) {</span>
<span class="nc" id="L225">                throw be;</span>
<span class="nc" id="L226">            } catch ( IllegalStateException ise ) {</span>
<span class="nc" id="L227">                String msg = ise.getMessage();</span>
<span class="nc bnc" id="L228" title="All 4 branches missed.">                if ( msg.contains(&quot;Cannot capture continuation&quot;) &amp;&amp; msg.contains(&quot;executeScriptWithContinuations or callFunctionWithContinuations&quot;) ){</span>
<span class="nc" id="L229">                    throw new BPjsCodeEvaluationException(&quot;bp.sync called outside of a b-thread&quot;);</span>
                } else {
<span class="nc" id="L231">                    throw ise;</span>
                }
<span class="nc" id="L233">            } catch ( Throwable generalException ) {</span>
<span class="nc" id="L234">                throw new BPjsRuntimeException(&quot;(Wrapped) Exception evaluating BProgram code: &quot; + generalException.getMessage(), generalException);</span>
            }

<span class="fc" id="L237">        } catch (EvaluatorException evalExp) {</span>
<span class="fc" id="L238">            throw new BPjsCodeEvaluationException(evalExp);</span>
            
<span class="nc" id="L240">        } catch ( Exception exp ) {</span>
<span class="nc" id="L241">            throw new BPjsRuntimeException(&quot;Error evaluating BProgram code: &quot; + exp.getMessage(), exp);</span>
        }
    }

    /**
     * Registers a BThread into the program. If the program started, the BThread
     * will take part in the current bstep.
     *
     * @param bt the BThread to be registered.
     */
    public void registerBThread(BThreadSyncSnapshot bt) {
<span class="fc" id="L252">        recentlyRegisteredBthreads.add(bt);</span>
<span class="fc" id="L253">        addBThreadCallback.ifPresent(cb -&gt; cb.bthreadAdded(this, bt));</span>
<span class="fc" id="L254">    }</span>
    
    void registerForkedChild( BThreadSyncSnapshot btss ) {
        // make the top-level scope be *this* program's programScope
<span class="nc" id="L258">        Scriptable pus = ScriptableUtils.getPenultiamteParent(btss.getScope());</span>
<span class="nc" id="L259">        pus.setParentScope(programScope);</span>
        
<span class="nc" id="L261">        addBThreadCallback.ifPresent(cb -&gt; cb.bthreadAdded(this, btss));</span>
<span class="nc" id="L262">    }</span>
    public void setStarted(boolean started){
<span class="nc" id="L264">        this.started = started;</span>
<span class="nc" id="L265">    }</span>
    /**
     * Adds an event to {@code this}' external event queue.
     *
     * @param e The event to add.
     */
    public void enqueueExternalEvent(BEvent e) {
<span class="nc" id="L272">        recentlyEnqueuedExternalEvents.add(e);</span>
<span class="nc" id="L273">    }</span>

    /**
     * Sets up the program scope and evaluates the program source.
     *
     * &lt;em&gt;This method can only be called once per instance.&lt;/em&gt;
     *
     * @return a snapshot of the program, after source code was executed, and
     * before any registered b-threads have run.
     * @throws IllegalStateException for repeated calls.
     */
    public BProgramSyncSnapshot setup() {
<span class="fc bfc" id="L285" title="All 2 branches covered.">        if (started) {</span>
<span class="fc" id="L286">            throw new IllegalStateException(&quot;Program already set up.&quot;);</span>
        }
<span class="fc" id="L288">        Set&lt;BThreadSyncSnapshot&gt; bthreads = drainRecentlyRegisteredBthreads();</span>

<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (eventSelectionStrategy == null) {</span>
<span class="fc" id="L291">            eventSelectionStrategy = new SimpleEventSelectionStrategy();</span>
        }
<span class="fc" id="L293">        FailedAssertion failedAssertion = null;</span>
        try {
<span class="fc" id="L295">            Context cx = ContextFactory.getGlobal().enterContext();</span>
<span class="fc" id="L296">            cx.setOptimizationLevel(-1); // must use interpreter mode</span>
<span class="fc" id="L297">            cx.setLanguageVersion( Context.VERSION_ES6);</span>
<span class="fc" id="L298">            initProgramScope(cx);</span>

            // evaluate code in order
<span class="fc bfc" id="L301" title="All 2 branches covered.">            if (prependedCode != null) {</span>
<span class="fc" id="L302">                prependedCode.forEach(s -&gt; evaluate(s, &quot;prependedCode&quot;));</span>
<span class="fc" id="L303">                prependedCode = null;</span>
            }
<span class="fc" id="L305">            setupProgramScope(programScope);</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">            if (appendedCode != null) {</span>
<span class="fc" id="L307">                appendedCode.forEach(s -&gt; evaluate(s, &quot;appendedCode&quot;));</span>
<span class="fc" id="L308">                appendedCode = null;</span>
            }

<span class="nc" id="L311">        } catch (FailedAssertionException fae) {</span>
<span class="nc" id="L312">            failedAssertion = new FailedAssertion(fae.getMessage(), &quot;---init_code&quot;);</span>

        } finally {
<span class="fc" id="L315">            Context.exit();</span>
        }

<span class="fc" id="L318">        started = true;</span>

<span class="fc" id="L320">        return new BProgramSyncSnapshot(this, bthreads, Collections.emptyList(), failedAssertion);</span>
    }

    private void initProgramScope(Context cx) {
        // load and execute globalScopeInit.js
<span class="fc" id="L325">        ImporterTopLevel importer = new ImporterTopLevel(cx);</span>
<span class="fc" id="L326">        programScope = cx.initStandardObjects(importer);</span>
<span class="fc" id="L327">        jsProxy = new BProgramJsProxy(this);</span>
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        if ( preSetLogLevel != null ) {</span>
<span class="nc" id="L329">            jsProxy.log.setLevel(preSetLogLevel.name());</span>
        }
<span class="fc" id="L331">        programScope.put(&quot;bp&quot;, programScope, Context.javaToJS(jsProxy, programScope));</span>

//        evaluateResource(&quot;globalScopeInit.js&quot;);// &lt;-- Currently not needed. Leaving in as we might need it soon.
<span class="fc" id="L334">        initialScopeValues.entrySet().forEach(e -&gt; putInGlobalScope(e.getKey(), e.getValue()));</span>
<span class="fc" id="L335">        initialScopeValues = null;</span>
<span class="fc" id="L336">    }</span>
   

    /**
     * The BProgram should set up its scope here. Normally, this amounts to
     * loading the script with the BThreads.
     *
     * @param scope the scope to set up.
     */
    protected abstract void setupProgramScope(Scriptable scope);

    /**
     * Blocks until an external event is added. Then, if that event is not the
     * &quot;stop daemon mode&quot; one, returns the event. Otherwise, returns
     * {@code null}.
     *
     * @return The event, or {@code null} in case the daemon mode is turned off
     * during the wait.
     * @throws InterruptedException (blocking call, we have to do this)
     */
    public BEvent takeExternalEvent() throws InterruptedException {
<span class="nc" id="L357">        BEvent next = recentlyEnqueuedExternalEvents.take();</span>

<span class="nc bnc" id="L359" title="All 2 branches missed.">        if (next == NO_MORE_WAIT_EXTERNAL) {</span>
<span class="nc" id="L360">            waitForExternalEvents = false;</span>
<span class="nc" id="L361">            return null;</span>
        } else {
<span class="nc" id="L363">            return next;</span>
        }
    }

    /**
     * Sets whether this program waits for external events or not.
     *
     * When set to {@code false}, when no events are available for selection,
     * the program terminates.
     *
     * @param shouldWait {@code true} causes the system to wait for external events. {@code false} causes it to not wait.
     */
    public void setWaitForExternalEvents(boolean shouldWait) {
<span class="nc bnc" id="L376" title="All 4 branches missed.">        if (waitForExternalEvents &amp;&amp; !shouldWait) {</span>
<span class="nc" id="L377">            waitForExternalEvents = false;</span>
<span class="nc" id="L378">            recentlyEnqueuedExternalEvents.add(NO_MORE_WAIT_EXTERNAL);</span>
        } else {
<span class="nc" id="L380">            waitForExternalEvents = shouldWait;</span>
        }
<span class="nc" id="L382">    }</span>

    /**
     * Returns {@code true} iff the program waits for external events. When
     * {@code true}, the program will not terminate when it has no event
     * available for selection. Rather, it will wait for an external event to be
     * enqueued into its external event queue.
     *
     * @return {@code true} if this BProgram waits for external events,
     * {@code false} otherwise.
     * @see #enqueueExternalEvent(il.ac.bgu.cs.bp.bpjs.model.BEvent) 
     */
    public boolean isWaitForExternalEvents() {
<span class="fc" id="L395">        return waitForExternalEvents;</span>
    }

    /**
     * Returns the program's global scope.
     *
     * @return the global scope of the program.
     */
    public Scriptable getGlobalScope() {
<span class="fc" id="L404">        return programScope;</span>
    }

    /**
     * Adds an object to the program's global scope. JS code can reference the
     * added object by {@code name}.
     *
     * @param name The name under which {@code object} will be available to the
     * JS code.
     * @param obj The object to be added to the program's scope.
     */
    public void putInGlobalScope(String name, Object obj) {
<span class="fc bfc" id="L416" title="All 2 branches covered.">        if (getGlobalScope() == null) {</span>
<span class="fc" id="L417">            initialScopeValues.put(name, obj);</span>
        } else {
            try {
<span class="fc" id="L420">                Context.enter();</span>
<span class="fc" id="L421">                getGlobalScope().put(name, programScope, Context.javaToJS(obj, programScope));</span>
            } finally {
<span class="fc" id="L423">                Context.exit();</span>
            }
        }
<span class="fc" id="L426">    }</span>

    /**
     * Gets the object pointer by the passed name in the global scope.
     *
     * @param &lt;T&gt; Class of the returned object.
     * @param name Name of the object in the JS heap.
     * @param clazz Class of the returned object
     * @return The object pointer by the passed name in the JS heap, converted
     * to the passed class.
     */
    public &lt;T&gt; Optional&lt;T&gt; getFromGlobalScope(String name, Class&lt;T&gt; clazz) {
<span class="fc bfc" id="L438" title="All 2 branches covered.">        if (getGlobalScope().has(name, programScope)) {</span>
<span class="fc" id="L439">            return Optional.of((T) Context.jsToJava(getGlobalScope().get(name, getGlobalScope()), clazz));</span>
        } else {
<span class="fc" id="L441">            return Optional.empty();</span>
        }
    }

    /**
     * Sets the name of the program
     *
     * @param name the new program's name
     */
    public void setName(String name) {
<span class="nc" id="L451">        this.name = name;</span>
<span class="nc" id="L452">    }</span>

    /**
     * @return the program's name
     */
    public String getName() {
<span class="fc" id="L458">        return name;</span>
    }
    
    Set&lt;BThreadSyncSnapshot&gt; drainRecentlyRegisteredBthreads() {
<span class="fc" id="L462">        Set&lt;BThreadSyncSnapshot&gt; out = new HashSet&lt;&gt;(recentlyRegisteredBthreads.size());</span>
<span class="fc" id="L463">        recentlyRegisteredBthreads.drainTo(out);</span>
<span class="fc" id="L464">        return out;</span>
    }
    public Set&lt;BThreadSyncSnapshot&gt; getRecentlyRegisteredBthreads() {
<span class="nc" id="L467">        Set&lt;BThreadSyncSnapshot&gt; out = new HashSet&lt;&gt;(recentlyRegisteredBthreads);</span>
<span class="nc" id="L468">        return out;</span>
    }
    List&lt;BEvent&gt; drainEnqueuedExternalEvents() {
<span class="fc" id="L471">        List&lt;BEvent&gt; out = new ArrayList&lt;&gt;(recentlyEnqueuedExternalEvents.size());</span>
<span class="fc" id="L472">        recentlyEnqueuedExternalEvents.drainTo(out);</span>
<span class="fc" id="L473">        return out;</span>
    }
    
    void addFork( ForkStatement fkStmt ) {
<span class="nc" id="L477">        recentlyAddedForks.add(fkStmt);</span>
<span class="nc" id="L478">    }</span>
    
    Set&lt;ForkStatement&gt; drainRecentlyAddedForks() {
<span class="fc" id="L481">        Set&lt;ForkStatement&gt; out = new HashSet&lt;&gt;();</span>
<span class="fc" id="L482">        recentlyAddedForks.drainTo(out);</span>
<span class="fc" id="L483">        return out;</span>
    }
    
    public void setAddBThreadCallback(BProgramCallback anAddBThreadCallback) {
<span class="fc" id="L487">        addBThreadCallback = Optional.ofNullable(anAddBThreadCallback);</span>
<span class="fc" id="L488">    }</span>

    public EventSelectionStrategy getEventSelectionStrategy() {
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">        if (eventSelectionStrategy == null) {</span>
<span class="nc" id="L492">            setEventSelectionStrategy(new SimpleEventSelectionStrategy());</span>
        }
<span class="fc" id="L494">        return eventSelectionStrategy;</span>
    }
    
    /**
     * Sets the event selection strategy to be used.
     * @param &lt;T&gt; Actual type of the strategy
     * @param anEventSelectionStrategy the strategy
     * @return the strategy (so it can be cleanly assigned to a variable).
     */
    public &lt;T extends EventSelectionStrategy&gt; T setEventSelectionStrategy(T anEventSelectionStrategy) {
<span class="fc" id="L504">        eventSelectionStrategy = anEventSelectionStrategy;</span>
<span class="fc" id="L505">        return anEventSelectionStrategy;</span>
    }
    
    public void setLogLevel( BpLog.LogLevel aLevel ) {
<span class="nc bnc" id="L509" title="All 2 branches missed.">        if ( jsProxy != null ) {</span>
<span class="nc" id="L510">            jsProxy.log.setLevel(aLevel.name());</span>
        } else {
<span class="nc" id="L512">            preSetLogLevel = aLevel;</span>
        }
<span class="nc" id="L514">    }</span>
    
    public BpLog.LogLevel getLogLevel() {
<span class="nc bnc" id="L517" title="All 2 branches missed.">        return (jsProxy != null ) ? BpLog.LogLevel.valueOf(jsProxy.log.getLevel()) : null;</span>
    }
    
    @Override
    public String toString() {
<span class="nc" id="L522">        return &quot;[BProgram &quot; + getName() + &quot;]&quot;;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>