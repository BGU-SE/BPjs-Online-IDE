<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SyncStatement.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bp-ide-bpjs-bp-framework</a> &gt; <a href="index.source.html" class="el_package">il.ac.bgu.cs.bp.bpjs.model</a> &gt; <span class="el_source">SyncStatement.java</span></div><h1>SyncStatement.java</h1><pre class="source lang-java linenums">package il.ac.bgu.cs.bp.bpjs.model;

import java.util.Objects;
import il.ac.bgu.cs.bp.bpjs.model.eventsets.EventSet;
import il.ac.bgu.cs.bp.bpjs.model.eventsets.ExplicitEventSet;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import static il.ac.bgu.cs.bp.bpjs.model.eventsets.EventSets.none;
import il.ac.bgu.cs.bp.bpjs.internal.OrderedSet;
import java.util.SortedSet;

/**
 * A statement a BThread makes at a synchronization point (i.e when {@code bp.sync} is called).
 * Contains data about what events it requests, waits for, and blocks, and possible additional data,
 * such as labels, or a break-upon event set.
 * 
 * @author michael
 */
public class SyncStatement implements java.io.Serializable {

    /**
     * The event requested by this statement
     */
    private final SortedSet&lt;? extends BEvent&gt; request;
    
    /**
     * The events waited for (wake thread up when these happen).
     */
    private final EventSet waitFor;
    
    /**
     * The events blocked while this statement is active.
     */
    private final EventSet block;
    
    /**
     * If any of these events happen, the stating thread wants to be terminated.
     */
    private final EventSet interrupt;    
    
    /**
     * When {@code true}, the b-thread states that it cannot stay in this
     * synchronization point forever.
     */
    private final boolean hot;
    
    /**
     * Optional data a BThread can pass to the event selector. This may serve as
     * a &quot;danger level&quot;, or any other hint for a specific event selection policy.
     */
    private final Object data;
    
    private BThreadSyncSnapshot bthread; 
    
    /**
     * Creates a new request where all fields are set to {@code empty}. To be
     * used as a DSL like manner:
     * &lt;code&gt;
     * BSyncStatement myStatement = make().request( XX ).waitFor( YY ).block( ZZZ );
     * &lt;/code&gt;
     * @param creator the {@link BThreadSyncSnapshot} that created this statement.
     * @return an empty statement
     */
    public static SyncStatement make(BThreadSyncSnapshot creator) {
<span class="fc" id="L67">        return new SyncStatement(creator, Collections.emptySet(), none, none, none, false, null);</span>
    }
    public static SyncStatement make() {
<span class="fc" id="L70">        return new SyncStatement(null, Collections.emptySet(), none, none, none, false, null);</span>
    }
    
<span class="fc" id="L73">    public SyncStatement(BThreadSyncSnapshot creator, Collection&lt;? extends BEvent&gt; request, EventSet waitFor, EventSet block, EventSet except, boolean isHot, Object data) {</span>
<span class="fc" id="L74">        this.request = new OrderedSet&lt;&gt;(request);</span>
<span class="fc" id="L75">        this.waitFor = waitFor;</span>
<span class="fc" id="L76">        this.block = block;</span>
<span class="fc" id="L77">        this.interrupt = except;</span>
<span class="fc" id="L78">        this.hot = isHot;</span>
<span class="fc" id="L79">        this.data = data;</span>
<span class="fc" id="L80">        this.bthread = creator;</span>
<span class="fc" id="L81">    }</span>

    public boolean shouldWakeFor( BEvent anEvent ) {
<span class="fc bfc" id="L84" title="All 4 branches covered.">        return request.contains(anEvent) || waitFor.contains(anEvent);</span>
    }
    
    /**
     * Creates a new {@link SyncStatement} based on {@code this}, with the 
     * request updated to the {@code toRequest} parameter.
     * @param toRequest the request part of the new statement
     * @return a new statement
     */
    public SyncStatement request( Collection&lt;? extends BEvent&gt; toRequest ) {
<span class="fc" id="L94">        return new SyncStatement(getBthread(), toRequest, getWaitFor(), getBlock(), getInterrupt(), isHot(), getData());</span>
    }
    public SyncStatement request( BEvent requestedEvent ) {
<span class="fc" id="L97">        Set&lt;BEvent&gt; toRequest = new HashSet&lt;&gt;();</span>
<span class="fc" id="L98">        toRequest.add(requestedEvent);</span>
<span class="fc" id="L99">        return new SyncStatement(getBthread(), toRequest, getWaitFor(), getBlock(), getInterrupt(), isHot(), getData());</span>
    }
    public SyncStatement request( ExplicitEventSet ees ) {
<span class="fc" id="L102">        return new SyncStatement(getBthread(), ees.getCollection(), getWaitFor(), getBlock(), getInterrupt(), isHot(), getData());</span>
    }
    
    public SyncStatement waitFor( EventSet events ) {
<span class="fc" id="L106">        return new SyncStatement(getBthread(), getRequest(), events, getBlock(), getInterrupt(), isHot(), getData());</span>
    }

    public SyncStatement block( EventSet events ) {
<span class="fc" id="L110">        return new SyncStatement(getBthread(), getRequest(), getWaitFor(), events, getInterrupt(), isHot(), getData());</span>
    }
    
    public SyncStatement interrupt( EventSet events ) {
<span class="fc" id="L114">        return new SyncStatement(getBthread(), getRequest(), getWaitFor(), getBlock(), events, isHot(), getData());</span>
    }
    
    public SyncStatement hot( boolean shouldBeHot ) { 
<span class="fc" id="L118">        return new SyncStatement(getBthread(), getRequest(), getWaitFor(), getBlock(), getInterrupt(), shouldBeHot, getData());</span>
    }
    
    public SyncStatement data( Object someData ) { 
<span class="fc" id="L122">        return new SyncStatement(getBthread(), getRequest(), getWaitFor(), getBlock(), getInterrupt(), isHot(), someData);</span>
    }

    public Collection&lt;? extends BEvent&gt; getRequest() {
<span class="fc" id="L126">        return request;</span>
    }

    public EventSet getWaitFor() {
<span class="fc" id="L130">        return waitFor;</span>
    }

    public EventSet getBlock() {
<span class="fc" id="L134">        return block;</span>
    }

    public EventSet getInterrupt() {
<span class="fc" id="L138">        return interrupt;</span>
    }

    public BThreadSyncSnapshot getBthread() {
<span class="fc" id="L142">        return bthread;</span>
    }

    public SyncStatement setBthread(BThreadSyncSnapshot bthread) {
<span class="fc" id="L146">        this.bthread = bthread;</span>
<span class="fc" id="L147">        return this;</span>
    }
    
    public Object getData() {
<span class="fc" id="L151">        return data;</span>
    }
    
    public boolean hasData() {
<span class="fc bfc" id="L155" title="All 2 branches covered.">        return data != null;</span>
    }

    public boolean isHot() {
<span class="fc" id="L159">        return hot;</span>
    }
        
    @Override
    public String toString() {
<span class="fc bfc" id="L164" title="All 2 branches covered.">        return String.format(&quot;[SyncStatement%s r:%s w:%s b:%s i:%s d:%s]&quot;, isHot()?&quot;&lt;hot&gt;&quot;:&quot;&quot;,</span>
<span class="fc" id="L165">                getRequest(), getWaitFor(), getBlock(), getInterrupt(), getData());</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L170">        return Objects.hash(getRequest(), getWaitFor(), getBlock(),</span>
<span class="fc" id="L171">                            getInterrupt(), getData(), isHot());</span>
    }

    @Override
    public boolean equals(Object obj) {
<span class="fc bfc" id="L176" title="All 2 branches covered.">        if (obj == this) return true;</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">        if (obj == null) return false;</span>
        
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (! (obj instanceof SyncStatement)) {</span>
<span class="fc" id="L180">            return false;</span>
        }
        
<span class="fc" id="L183">        final SyncStatement other = (SyncStatement) obj;</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">        if ( this.isHot() != other.isHot() ) {</span>
<span class="fc" id="L185">            return false;</span>
        }
<span class="fc bfc" id="L187" title="All 2 branches covered.">        if (!Objects.equals(this.getRequest(), other.getRequest())) {</span>
<span class="fc" id="L188">            return false;</span>
        }
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        if (!Objects.equals(this.getWaitFor(), other.getWaitFor())) {</span>
<span class="nc" id="L191">            return false;</span>
        }
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        if (!Objects.equals(this.getBlock(), other.getBlock())) {</span>
<span class="nc" id="L194">            return false;</span>
        }
<span class="fc bfc" id="L196" title="All 2 branches covered.">        if (!Objects.equals(this.getInterrupt(), other.getInterrupt())) {</span>
<span class="fc" id="L197">            return false;</span>
        }
<span class="fc" id="L199">        return Objects.equals(getData(), other.getData());</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>