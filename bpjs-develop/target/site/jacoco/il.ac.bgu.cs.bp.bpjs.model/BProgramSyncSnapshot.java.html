<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BProgramSyncSnapshot.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bp-ide-bpjs-bp-framework</a> &gt; <a href="index.source.html" class="el_package">il.ac.bgu.cs.bp.bpjs.model</a> &gt; <span class="el_source">BProgramSyncSnapshot.java</span></div><h1>BProgramSyncSnapshot.java</h1><pre class="source lang-java linenums">package il.ac.bgu.cs.bp.bpjs.model;

import il.ac.bgu.cs.bp.bpjs.bprogramio.BProgramSyncSnapshotIO;
import il.ac.bgu.cs.bp.bpjs.bprogramio.BThreadSyncSnapshotInputStream;
import il.ac.bgu.cs.bp.bpjs.bprogramio.StreamObjectStub;
import il.ac.bgu.cs.bp.bpjs.bprogramio.StubProvider;
import il.ac.bgu.cs.bp.bpjs.exceptions.BPjsException;
import il.ac.bgu.cs.bp.bpjs.exceptions.BPjsRuntimeException;
import il.ac.bgu.cs.bp.bpjs.execution.jsproxy.BProgramJsProxy;
import il.ac.bgu.cs.bp.bpjs.execution.tasks.ResumeBThread;
import il.ac.bgu.cs.bp.bpjs.execution.tasks.StartBThread;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;
import org.mozilla.javascript.Context;
import il.ac.bgu.cs.bp.bpjs.execution.listeners.BProgramRunnerListener;
import il.ac.bgu.cs.bp.bpjs.execution.tasks.BPEngineTask;
import il.ac.bgu.cs.bp.bpjs.execution.tasks.StartFork;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Stream;
import org.mozilla.javascript.ContinuationPending;
import org.mozilla.javascript.EcmaError;
import org.mozilla.javascript.Scriptable;
import org.mozilla.javascript.ScriptableObject;

/**
 * The state of a {@link BProgram} when all its BThreads are at {@code bsync}.
 * This is more than a set of {@link BThreadSyncSnapshot}s, as it contains
 * the queue of external events as well.
 * 
 * @author michael
 */
public class BProgramSyncSnapshot {
    
<span class="fc" id="L48">    private static final AtomicInteger FORK_NEXT_ID = new AtomicInteger(0);</span>
    
    private final Set&lt;BThreadSyncSnapshot&gt; threadSnapshots;
    private final List&lt;BEvent&gt; externalEvents;
    private final BProgram bprog;
<span class="fc" id="L53">    private final AtomicReference&lt;FailedAssertion&gt; violationRecord = new AtomicReference&lt;&gt;();</span>
<span class="fc" id="L54">    private int hashCodeCache = Integer.MIN_VALUE;</span>
    
    /** A flag to ensure the snapshot is only triggered once. */
<span class="fc" id="L57">    private boolean triggered=false;</span>
    
    /**
     * A listener that populates the {@link #violationRecord} field.
     */
    private static class ViolationRecorder implements BPEngineTask.Listener {
        private final BProgram bprogram;
        private final AtomicReference&lt;FailedAssertion&gt; vioRec;

<span class="fc" id="L66">        public ViolationRecorder(BProgram bprogram, AtomicReference&lt;FailedAssertion&gt; aViolationRecord) {</span>
<span class="fc" id="L67">            this.bprogram = bprogram;</span>
<span class="fc" id="L68">            vioRec = aViolationRecord;</span>
<span class="fc" id="L69">        }</span>
        
        @Override
        public void assertionFailed(FailedAssertion fa) {
<span class="fc" id="L73">            vioRec.compareAndSet(null, fa);</span>
<span class="fc" id="L74">        }</span>

        @Override
        public void addFork(ForkStatement stmt) {
<span class="nc" id="L78">            bprogram.addFork(stmt);</span>
<span class="nc" id="L79">        }</span>
    }
    
    public BProgramSyncSnapshot(BProgram aBProgram, Set&lt;BThreadSyncSnapshot&gt; someThreadSnapshots,
<span class="fc" id="L83">                                List&lt;BEvent&gt; someExternalEvents, FailedAssertion aViolationRecord ) {</span>
<span class="fc" id="L84">        threadSnapshots = someThreadSnapshots;</span>
<span class="fc" id="L85">        externalEvents = someExternalEvents;</span>
<span class="fc" id="L86">        bprog = aBProgram;</span>
<span class="fc" id="L87">        violationRecord.set(aViolationRecord);</span>
<span class="fc" id="L88">    }</span>
    
    public BProgramSyncSnapshot copyWith( List&lt;BEvent&gt; updatedExternalEvents ) {
<span class="nc" id="L91">        return new BProgramSyncSnapshot(bprog, threadSnapshots, updatedExternalEvents, violationRecord.get());</span>
    }

    /**
     * Starts the BProgram - runs all the registered b-threads to their first 
     * {@code bp.sync}. 
     * 
     * @param exSvc the executor service that will advance the threads.
     * @return A snapshot of the program at the first {@code bp.sync}.
     * @throws java.lang.InterruptedException (since it's a blocking call)
     */
    public BProgramSyncSnapshot start( ExecutorService exSvc ) throws InterruptedException {
<span class="fc" id="L103">        Set&lt;BThreadSyncSnapshot&gt; nextRound = new HashSet&lt;&gt;(threadSnapshots.size());</span>
<span class="fc" id="L104">        BPEngineTask.Listener halter = new ViolationRecorder(bprog, violationRecord);</span>
<span class="fc" id="L105">        nextRound.addAll(exSvc.invokeAll(threadSnapshots.stream()</span>
<span class="pc" id="L106">                                .map(bt -&gt; new StartBThread(bt, halter))</span>
<span class="fc" id="L107">                                .collect(toList())</span>
<span class="pc" id="L108">                ).stream().map(f -&gt; safeGet(f) ).collect(toList())</span>
        );
<span class="fc" id="L110">        executeAllAddedBThreads(nextRound, exSvc, halter);</span>
<span class="fc" id="L111">        List&lt;BEvent&gt; nextExternalEvents = new ArrayList&lt;&gt;(getExternalEvents());</span>
<span class="fc" id="L112">        nextExternalEvents.addAll( bprog.drainEnqueuedExternalEvents() );</span>
<span class="fc" id="L113">        return new BProgramSyncSnapshot(bprog, nextRound, nextExternalEvents, violationRecord.get());</span>
    }

    /**
     * Runs the program from the snapshot, triggering the passed event.
     * @param exSvc the executor service that will advance the threads.
     * @param anEvent the event selected.
     * @param listeners will be informed in case of b-thread interrupts
     * @return A set of b-thread snapshots that should participate in the next cycle.
     * @throws InterruptedException (since it's a blocking call)
     */
    public BProgramSyncSnapshot triggerEvent(BEvent anEvent, ExecutorService exSvc, Iterable&lt;BProgramRunnerListener&gt; listeners) throws InterruptedException, BPjsRuntimeException {
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if (anEvent == null) throw new IllegalArgumentException(&quot;Cannot trigger a null event.&quot;);</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if ( triggered ) {</span>
<span class="fc" id="L127">            throw new IllegalStateException(&quot;A BProgramSyncSnapshot is not allowed to be triggered twice.&quot;);</span>
    	}
<span class="fc" id="L129">    	triggered = true;</span>
<span class="fc" id="L130">        listeners.forEach(l-&gt;l.eventSelected(bprog, anEvent));</span>

<span class="fc" id="L132">        Set&lt;BThreadSyncSnapshot&gt; resumingThisRound = new HashSet&lt;&gt;(threadSnapshots.size());</span>
<span class="fc" id="L133">        Set&lt;BThreadSyncSnapshot&gt; sleepingThisRound = new HashSet&lt;&gt;(threadSnapshots.size());</span>
<span class="fc" id="L134">        List&lt;BEvent&gt; nextExternalEvents = new ArrayList&lt;&gt;(getExternalEvents());</span>
        try {
<span class="fc" id="L136">            Context ctxt = Context.enter();</span>
<span class="fc" id="L137">            handleInterrupts(anEvent, listeners, bprog, ctxt);</span>
<span class="fc" id="L138">            nextExternalEvents.addAll(bprog.drainEnqueuedExternalEvents());</span>
            
            // Split threads to those that advance this round and those that sleep.
<span class="fc" id="L141">            threadSnapshots.forEach( snapshot -&gt; {</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">                (snapshot.getSyncStatement().shouldWakeFor(anEvent) ? resumingThisRound : sleepingThisRound).add(snapshot);</span>
<span class="fc" id="L143">            });</span>
        } finally {
<span class="fc" id="L145">            Context.exit();</span>
        }
        
<span class="fc" id="L148">        BPEngineTask.Listener halter = new ViolationRecorder(bprog, violationRecord);</span>

        // add the run results of all those who advance this stage
<span class="fc" id="L151">        Set&lt;BThreadSyncSnapshot&gt; nextRound = new HashSet&lt;&gt;(threadSnapshots.size());</span>
        try {
<span class="fc" id="L153">            nextRound.addAll(exSvc.invokeAll(</span>
<span class="fc" id="L154">                                resumingThisRound.stream()</span>
<span class="fc" id="L155">                                                 .map(bt -&gt; new ResumeBThread(bt, anEvent, halter))</span>
<span class="fc" id="L156">                                                 .collect(toList())</span>
<span class="fc" id="L157">                    ).stream().map(f -&gt; safeGet(f)).filter(Objects::nonNull).collect(toList())</span>
            );

            // inform listeners which b-threads completed
<span class="fc" id="L161">            Set&lt;String&gt; nextRoundIds = nextRound.stream().map(t-&gt;t.getName()).collect(toSet());</span>
<span class="fc" id="L162">            resumingThisRound.stream()</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">                    .filter(t-&gt;!nextRoundIds.contains(t.getName()))</span>
<span class="fc" id="L164">                    .forEach(t-&gt;listeners.forEach(l-&gt;l.bthreadDone(bprog, t)));</span>

<span class="fc" id="L166">            executeAllAddedBThreads(nextRound, exSvc, halter);</span>
            
<span class="fc" id="L168">        } catch ( BPjsException re ) { </span>
<span class="fc" id="L169">            throw re;</span>
            
<span class="nc" id="L171">        } catch ( RuntimeException re ) { </span>
            // try to peel the exception layers to get to the meaningful exception.
<span class="nc" id="L173">            Throwable cause = re;</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">            while ( cause instanceof RuntimeException  ) {</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                if ( cause.getCause() != null ) {</span>
<span class="nc" id="L176">                    cause = cause.getCause();</span>
                } else {
<span class="nc" id="L178">                    throw (RuntimeException)cause;</span>
                }
            }
<span class="nc bnc" id="L181" title="All 2 branches missed.">            if ( cause instanceof ExecutionException ) {</span>
<span class="nc" id="L182">                cause = cause.getCause();</span>
            }
            
<span class="nc bnc" id="L185" title="All 2 branches missed.">            if ( cause instanceof BPjsException ) {</span>
<span class="nc" id="L186">                throw (BPjsException)cause;</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">            } else if ( cause instanceof EcmaError ) {</span>
<span class="nc" id="L188">                throw new BPjsRuntimeException(&quot;JavaScript Error: &quot; + cause.getMessage(), cause );</span>
<span class="nc" id="L189">            } else throw re;</span>
<span class="fc" id="L190">        }</span>
        
<span class="fc" id="L192">        nextExternalEvents.addAll( bprog.drainEnqueuedExternalEvents() );</span>

        // carry over BThreads that did not advance this round to next round.
<span class="fc" id="L195">        nextRound.addAll(sleepingThisRound);</span>


<span class="fc" id="L198">        return new BProgramSyncSnapshot(bprog, nextRound, nextExternalEvents, violationRecord.get());</span>
        
    }
    
    private void handleInterrupts(BEvent anEvent, Iterable&lt;BProgramRunnerListener&gt; listeners, BProgram bprog, Context ctxt) {
<span class="fc" id="L203">        Set&lt;BThreadSyncSnapshot&gt; interrupted = threadSnapshots.stream()</span>
<span class="fc" id="L204">                .filter(bt -&gt; bt.getSyncStatement().getInterrupt().contains(anEvent))</span>
<span class="fc" id="L205">                .collect(toSet());</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">        if (!interrupted.isEmpty()) {</span>
<span class="nc" id="L207">            threadSnapshots.removeAll(interrupted);</span>
<span class="nc" id="L208">            interrupted.forEach(bt -&gt; {</span>
<span class="nc" id="L209">                listeners.forEach(l -&gt; l.bthreadRemoved(bprog, bt));</span>
<span class="nc" id="L210">                bt.getInterrupt()</span>
<span class="nc" id="L211">                        .ifPresent( func -&gt; {</span>
<span class="nc" id="L212">                            final Scriptable scope = bt.getScope();</span>
                            try {
<span class="nc" id="L214">                                ctxt.callFunctionWithContinuations(func, scope, new Object[]{anEvent});</span>
<span class="nc" id="L215">                            } catch ( ContinuationPending ise ) {</span>
<span class="nc" id="L216">                                throw new BPjsRuntimeException(&quot;Cannot call bp.sync or fork from a break-upon handler. Please consider pushing an external event.&quot;);</span>
<span class="nc" id="L217">                            }</span>
<span class="nc" id="L218">                        });</span>
<span class="nc" id="L219">            });</span>
        }
<span class="fc" id="L221">    }</span>

    public List&lt;BEvent&gt; getExternalEvents() {
<span class="fc" id="L224">        return externalEvents;</span>
    }

    public Set&lt;BThreadSyncSnapshot&gt; getBThreadSnapshots() {
<span class="fc" id="L228">        return threadSnapshots;</span>
    }
    
    public Set&lt;SyncStatement&gt; getStatements() {
<span class="fc" id="L232">        return getBThreadSnapshots().stream().map(BThreadSyncSnapshot::getSyncStatement)</span>
<span class="fc" id="L233">                .collect(toSet());</span>
    }
    
    /**
     * Does this snapshot have any b-threads to run? If not, this means that
     * the b-program has terminated.
     * 
     * @return {@code true} iff the snapshot contains b-threads.
     */
    public boolean noBThreadsLeft() {
<span class="fc" id="L243">        return threadSnapshots.isEmpty();</span>
    }
    
    /**
     * 
     * @return The BProgram this object is a snapshot of.
     */
    public BProgram getBProgram() {
<span class="fc" id="L251">        return bprog;</span>
    }
    
    /**
     * If the b-program has violated some requirement while getting to {@code this}
     * state, it is considered to be in &lt;b&gt;invalid&lt;/b&gt; state. This happens when
     * a b-thread makes an failed assertion.
     * 
     * @return {@code true} iff the program is in valid state.
     * @see #getFailedAssertion() 
     */
    public boolean isStateValid() {
<span class="fc bfc" id="L263" title="All 2 branches covered.">        return violationRecord.get() == null;</span>
    }
    
    public FailedAssertion getFailedAssertion() {
<span class="fc" id="L267">        return violationRecord.get();</span>
    }
    
    /**
     * Returns {@code true} if any of the b-threads at this point is at a &quot;hot&quot;
     * sync. Similar to the &quot;hot cut&quot; idiom in LSC.
     * @return {@code true} is at least one of the b-threads is at a hot sync; {@code false} otherwise.
     */
    public boolean isHot() {
<span class="fc" id="L276">        return getBThreadSnapshots().stream()</span>
<span class="fc" id="L277">                    .map(BThreadSyncSnapshot::getSyncStatement)</span>
<span class="fc" id="L278">                    .filter(SyncStatement::isHot)</span>
<span class="fc" id="L279">                    .findAny().isPresent();</span>
    }
    
    private BThreadSyncSnapshot safeGet(Future&lt;BThreadSyncSnapshot&gt; fbss) {
        try {
<span class="fc" id="L284">            return fbss.get();</span>
<span class="fc" id="L285">        } catch (InterruptedException | ExecutionException ex) {</span>
<span class="fc" id="L286">            Logger.getLogger(BProgramSyncSnapshot.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">            if ( ex.getCause() instanceof BPjsException ) {</span>
<span class="fc" id="L288">                throw (BPjsException)ex.getCause();</span>
            } else {
<span class="nc" id="L290">                throw new RuntimeException(&quot;Error running a b-thread: &quot; + ex.getMessage(), ex);</span>
            }
        }
    }
    
    /**
     * Executes and adds all newly registered b-threads, until no more new b-threads 
     * are registered.
     * @param nextRound the set of b-threads that will participate in the next round
     * @param exSvc The executor service to run the b-threads
     * @param listener handling assertion failures, if they happen.
     * @throws InterruptedException 
     */
    private void executeAllAddedBThreads(Set&lt;BThreadSyncSnapshot&gt; nextRound, ExecutorService exSvc, BPEngineTask.Listener listener) throws InterruptedException {
        // if any new bthreads are added, run and add their result
<span class="fc" id="L305">        Set&lt;BThreadSyncSnapshot&gt; addedBThreads = bprog.drainRecentlyRegisteredBthreads();</span>
<span class="fc" id="L306">        Set&lt;ForkStatement&gt; addedForks = bprog.drainRecentlyAddedForks();</span>
<span class="pc bpc" id="L307" title="1 of 4 branches missed.">        while ( ((!addedBThreads.isEmpty()) || (!addedForks.isEmpty())) </span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">                &amp;&amp; !exSvc.isShutdown() ) {</span>
<span class="fc" id="L309">            Stream&lt;BPEngineTask&gt; threadStream = addedBThreads.stream()</span>
<span class="fc" id="L310">                .map(bt -&gt; new StartBThread(bt, listener));</span>
<span class="pc" id="L311">            Stream&lt;BPEngineTask&gt; forkStream = addedForks.stream().flatMap( f -&gt; convertToTasks(f, listener) );</span>
            
<span class="fc" id="L313">            nextRound.addAll(exSvc.invokeAll(Stream.concat(forkStream, threadStream).collect(toList())).stream()</span>
<span class="fc" id="L314">                     .map(f -&gt; safeGet(f) ).filter(Objects::nonNull).collect(toList()));</span>
<span class="fc" id="L315">            addedBThreads = bprog.drainRecentlyRegisteredBthreads();</span>
<span class="fc" id="L316">            addedForks = bprog.drainRecentlyAddedForks();</span>
<span class="fc" id="L317">        }</span>
<span class="fc" id="L318">    }</span>
    
    Stream&lt;StartFork&gt; convertToTasks(ForkStatement fkStmt, BPEngineTask.Listener listener) {
        
        // read continuation
<span class="nc" id="L323">        Object cont=null;</span>
<span class="nc" id="L324">        final BProgramJsProxy bpProxy = new BProgramJsProxy(bprog);</span>

<span class="nc" id="L326">        StubProvider stubPrv = (StreamObjectStub stub) -&gt; {</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">            if (stub == StreamObjectStub.BP_PROXY) {</span>
<span class="nc" id="L328">                return bpProxy;</span>
            }
<span class="nc" id="L330">            throw new IllegalArgumentException(&quot;Unknown stub &quot; + stub);</span>
        };

<span class="nc" id="L333">        try ( ByteArrayInputStream bais = new ByteArrayInputStream(fkStmt.getSerializedContinuation());</span>
<span class="nc" id="L334">            BThreadSyncSnapshotInputStream bssis = new BThreadSyncSnapshotInputStream(bais,</span>
<span class="nc" id="L335">                                                                ScriptableObject.getTopLevelScope(bprog.getGlobalScope()), stubPrv) ) {</span>
<span class="nc" id="L336">            cont = bssis.readObject();</span>
<span class="nc" id="L337">        } catch (ClassNotFoundException|IOException ex) {</span>
<span class="nc" id="L338">            throw new RuntimeException(&quot;Error while deserializing fork continuation: &quot; + ex.getMessage(), ex);</span>
<span class="nc" id="L339">        }</span>
        
        // construct a BThreadSyncSnapshot
<span class="nc" id="L342">        BThreadSyncSnapshot btss = new BThreadSyncSnapshot(</span>
<span class="nc" id="L343">            &quot;f&quot; + FORK_NEXT_ID.incrementAndGet() + &quot;$&quot; + fkStmt.getForkingBThread().getName(),</span>
<span class="nc" id="L344">            fkStmt.getForkingBThread().getEntryPoint(), </span>
<span class="nc" id="L345">            fkStmt.getForkingBThread().getInterrupt().orElse(null),</span>
            cont,
            null
        );
        
        // duplicate snapshot and register the copy with the b-program
        try {
<span class="nc" id="L352">            Context.enter();</span>
<span class="nc" id="L353">            BProgramSyncSnapshotIO io = new BProgramSyncSnapshotIO(bprog);</span>
<span class="nc" id="L354">            BThreadSyncSnapshot forkedBT = io.deserializeBThread(io.serializeBThread(btss));</span>
<span class="nc" id="L355">            bprog.registerForkedChild(btss);</span>
<span class="nc" id="L356">            return Stream.of(new StartFork(fkStmt, forkedBT, listener, bprog));</span>
        } finally {
<span class="nc" id="L358">            Context.exit();</span>
        }
    }
    
    @Override
    public int hashCode() {
<span class="fc bfc" id="L364" title="All 2 branches covered.">        if ( hashCodeCache == Integer.MIN_VALUE  ) {</span>
<span class="fc" id="L365">            hashCodeCache = (threadSnapshots.hashCode()+1) * (externalEvents.hashCode()+1);</span>
        }
<span class="fc" id="L367">        return hashCodeCache;</span>
    }

    @Override
    public boolean equals(Object obj) {
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (this == obj)</span>
<span class="fc" id="L373">            return true;</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">        if (obj == null)</span>
<span class="fc" id="L375">            return false;</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (getClass() != obj.getClass())</span>
<span class="fc" id="L377">            return false;</span>
<span class="fc" id="L378">        BProgramSyncSnapshot other = (BProgramSyncSnapshot) obj;</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">        if (isStateValid() != other.isStateValid()) {</span>
<span class="nc" id="L380">            return false;</span>
        }
<span class="fc bfc" id="L382" title="All 2 branches covered.">        if (!isStateValid()) {</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">            if (!getFailedAssertion().equals(other.getFailedAssertion()) ) {</span>
<span class="fc" id="L384">                return false;</span>
            }
        }
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        if ( ! getExternalEvents().equals(other.getExternalEvents()) ) {</span>
<span class="nc" id="L388">            return false;</span>
        }
        // optimization: non-equality by hash code - if we have one.
<span class="pc bpc" id="L391" title="1 of 4 branches missed.">        if ( hashCodeCache != Integer.MIN_VALUE &amp;&amp; other.hashCodeCache != Integer.MIN_VALUE ) {</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">            if ( hashCodeCache != other.hashCodeCache ) return false;</span>
        }
<span class="fc" id="L394">        return Objects.equals(threadSnapshots, other.threadSnapshots);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>